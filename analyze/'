#include "utils/utils.h"
#include "utils/rand.h"
#include "tree_compare.h"

void run_tree_compare(void)
{
	puts("ooga booga");

	struct BTreeNode *root1 = init_tree1();
	struct BTreeNode *root2 = init_tree2();
	struct BTreeNode *root3 = init_tree3();
	struct BTreeNode *root4 = init_tree4();
	struct BTreeNode *root5 = init_tree5();

	printf("%s\n",
	       similar_binary_trees(root1, root1) ?  "similar" : "different");

	free_nodes(root1);
}

bool similar_binary_trees(struct BTreeNode *node1,
			  struct BTreeNode *node2)
{

	if (node1 == NULL)
		return node2 == NULL;

	if (node1->value != node2->value)
		return false;

	return (similar_binary_trees(node1->l_child, node2->l_child)  &&
		similar_binary_trees(node1->r_child, node2->r_child))
	    || (similar_binary_trees(node1->l_child, node2->r_child)  &&
		similar_binary_trees(node1->r_child, node2->l_child));
}

/*
 *		┌────── 0 ──────┐
 *	┌──────	1 ──────┐	2
 *	3	┌────── 4
 *		5
 */
struct BTreeNode *init_tree1(void)
{
	struct BTreeNode *nodes[6];
	init_nodes(&nodes[0], 6);
	set_children(nodes[0], nodes[1], nodes[2]);
	set_children(nodes[1], nodes[3], nodes[4]);
	set_children(nodes[2], NULL,	 NULL);
	set_children(nodes[3], NULL,	 NULL);
	set_children(nodes[4], nodes[5], NULL);
	set_children(nodes[5], NULL,	 NULL);
	return nodes[0];
}

/*
 *		┌────── 0 ──────┐
 *	┌──────	2 ──────┐	1
 *	3	┌────── 4
 *		5
 */
struct BTreeNode *init_tree2(void)
{
	struct BTreeNode *nodes[6];
	init_nodes(&nodes[0], 6);
	set_children(nodes[0], nodes[2], nodes[1]);
	set_children(nodes[1], NULL,	 NULL);
	set_children(nodes[2], nodes[3], nodes[4]);
	set_children(nodes[3], NULL,	 NULL);
	set_children(nodes[4], nodes[5], NULL);
	set_children(nodes[5], NULL,	 NULL);
	return nodes[0];
}
/*
 *		┌────── 0 ──────┐
 *	┌──────	1 ──────┐	2
 *	4	┌────── 3
 *		5
 */
struct BTreeNode *init_tree3(void)
{
	struct BTreeNode *nodes[6];
	init_nodes(&nodes[0], 6);
	set_children(nodes[0], nodes[1], nodes[2]);
	set_children(nodes[1], nodes[3], nodes[4]);
	set_children(nodes[2], NULL,	 NULL);
	set_children(nodes[3], nodes[5], NULL);
	set_children(nodes[4], NULL,	 NULL);
	set_children(nodes[5], NULL,	 NULL);
	return nodes[0];
}

/*
 *		┌────── 0 ──────┐
 *	┌──────	2		1 ──────┐
 *	4				3 ──────┐
 *						5
 */
struct BTreeNode *init_tree4(void)
{
	struct BTreeNode *nodes[6];
	init_nodes(&nodes[0], 6);
	set_children(nodes[0], nodes[2], nodes[1]);
	set_children(nodes[1], NULL,	 nodes[3]);
	set_children(nodes[2], nodes[4], NULL);
	set_children(nodes[3], NULL,	 nodes[5]);
	set_children(nodes[4], NULL,	 NULL);
	set_children(nodes[5], NULL,	 NULL);
	return nodes[0];
}

/*
 *		┌────── 0 ──────┐
 *	┌──────	1 ──────┐	2
 *	3		4
 */
struct BTreeNode *init_tree5(void)
{
	struct BTreeNode *nodes[5];
	init_nodes(&nodes[0], 5);
	set_children(nodes[0], nodes[1], nodes[2]);
	set_children(nodes[1], nodes[3], nodes[4]);
	set_children(nodes[2], NULL,	 NULL);
	set_children(nodes[3], NULL,	 NULL);
	set_children(nodes[4], NULL, NULL);
	return nodes[0];
}

inline void set_children(struct BTreeNode *parent,
			 struct BTreeNode *l_child,
			 struct BTreeNode *r_child)
{
	parent->l_child = l_child;
	parent->r_child = r_child;
}

inline void init_nodes(struct BTreeNode **nodes,
		       const size_t count)
{
	for (int i = 0; i < count; ++i) {
		HANDLE_MALLOC(nodes[i], sizeof(struct BTreeNode));
		nodes[i]->value = i;
	}
}

inline void free_tree(struct BTree *tree)
{
	free_nodes(tree->root);
}

inline void free_nodes(struct BTreeNode *root)
{
	if (root == NULL)
		return;

	free_nodes(root->l_child);
	free_nodes(root->r_child);
	free(root);
}
